{"version":3,"sources":["../render-texture.fsx"],"names":[],"mappings":";;;;;;;AAAA,oCAkBe,iCAlBf;AAAA,kCAoBc,+BApBd;AAqBA;AArBA,8BAwBY,qBAxBZ;AAAA,8CA2BE,kEA3BF;AAAA,gDA6BE,kEA7BF;AAAA,4CAgCmB,+BAhCnB;AAmCA;AACA;AACA;AAGA;AAxCA,gDA0CqB,qBA1CrB;AA2CA;AACA;AACA;AA7CA;AAAA;;AAgEA,gCACM;AAAO,6CAAyB,iBAAzB;;AACX,sBAAmB,yBAAnB;AACA,sBAAmB,yBAAnB;AACA;AACA;AACA;AALQ;;AAjEV,kCAyEc;AAAA;;AAEV;AAAA,mCAAkD;AAAA;AAAO,OAAzD;AAGS;AACT;;AACA,oCACM;AAAO;AACX,wBAAiB,mBAAjB;AADQ;;AAGV,cAAS,YAAT;AATA;AAaA;AACA;AAGA;AAGA,gCAA2B,8BAA3B;AACA,6BAAuB,IAAK,qBAA5B;AAIA;AAGA;AAAsB,KA5BtB;;AAFU;AAAK,GAAL,EAzEd;;AA2GA","file":"render-texture.js","sourceRoot":"/Users/alfonsogarciacaronunez/Documents/Github/fable-graphics/samples/pixi/render-texture/public","sourcesContent":["(**\n - title: Render Texture sample\n - tagline: Basic sample implemented with fable-pixi\n - app-style: width:800px; margin:20px auto 50px auto;\n - require-paths: `'PIXI':'https://cdnjs.cloudflare.com/ajax/libs/pixi.js/3.0.11/pixi.min'`\n - intro: This is a port from [Render texture sample](http://pixijs.github.io/examples/#/demos/render-texture-demo.js)\n*)\n\n#r \"../../node_modules/fable-core/Fable.Core.dll\"\n#load \"../../node_modules/fable-import-pixi/Fable.Import.Pixi.fs\"\n\nopen System\nopen Fable.Core\nopen Fable.Core.JsInterop\nopen Fable.Import.PIXI\nopen Fable.Import.Browser\nopen Fable.Import.JS\n\nlet renderer = WebGLRenderer( 800., 600. )\n\nlet gameDiv = document.getElementById(\"game\")\ngameDiv.appendChild( renderer.view )\n\n// create the root of the scene graph\nlet stage = Container()\n\nlet mutable renderTexture =\n  RenderTexture( U2.Case2 renderer, renderer.width, renderer.height)\nlet mutable renderTexture2 =\n  RenderTexture( U2.Case2 renderer, renderer.width, renderer.height)\n\n// create a new sprite that uses the render texture we created above\nlet outputSprite = Sprite(renderTexture)\n\n// align the sprite\noutputSprite.position.x <- 400.\noutputSprite.position.y <- 300.\noutputSprite.anchor.set(0.5)\n\n// add to stage\nstage.addChild(outputSprite)\n\nlet stuffContainer = Container()\nstuffContainer.position.x <- 400.\nstuffContainer.position.y <- 300.\nstage.addChild(stuffContainer)\n\n// create an array of image ids\nlet fruits =\n  ResizeArray [|\n    \"./public/assets/spinObj_01.png\";\n    \"./public/assets/spinObj_02.png\";\n    \"./public/assets/spinObj_03.png\";\n    \"./public/assets/spinObj_04.png\";\n    \"./public/assets/spinObj_05.png\";\n    \"./public/assets/spinObj_06.png\";\n    \"./public/assets/spinObj_07.png\";\n    \"./public/assets/spinObj_08.png\"\n  |]\n\n// create an array of items\nlet items = ResizeArray<Sprite>()\n\n// now create some items and randomly position them in the stuff container\nfor i in 0..19 do\n  let item = Sprite.fromImage(fruits.[i % fruits.Count])\n  item.position.x <- Math.random() * 400. - 200.\n  item.position.y <- Math.random() * 400. - 200.\n  item.anchor.set(0.5)\n  stuffContainer.addChild(item) |> ignore\n  items.Add(item)\n\nlet animate =\n  let mutable count = 0.\n  let rec animate (dt:float) =\n    window.requestAnimationFrame(FrameRequestCallback animate)\n    |> ignore\n\n    let il = items.Count - 1\n    console.log(il)\n    for i in 0..il do\n      let item = items.[i]\n      item.rotation <- item.rotation + 0.1\n\n    count <- count + 0.01\n\n    // swap the buffers ...\n    let temp = renderTexture\n    renderTexture <- renderTexture2\n    renderTexture2 <- temp\n\n    // set the new texture\n    outputSprite.texture <- renderTexture\n\n    // twist this up!\n    stuffContainer.rotation <- stuffContainer.rotation - 0.01\n    outputSprite.scale.set(1. + Math.sin(float count) * 0.2)\n\n    // render the stage to the texture\n    // the 'true' clears the texture before the content is rendered\n    renderTexture2.render(displayObject=stage, clear=false)\n\n    // render the container\n    renderer.render(stage)\n  \n  animate // Return `animate` function with `count` trapped in a closure\n\nanimate 0.\n"]}