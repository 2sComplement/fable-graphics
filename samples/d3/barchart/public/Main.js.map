{"version":3,"file":null,"sources":["../../../node_modules/fable-core/Symbol.js","../../../node_modules/fable-core/Util.js","../../../node_modules/fable-core/ListClass.js","../../../node_modules/fable-core/Seq.js","../../../node_modules/fable-core/RegExp.js","../../../node_modules/fable-core/TimeSpan.js","../../../node_modules/fable-core/Date.js","../../../node_modules/fable-core/String.js","../barchart.fsx"],"sourcesContent":["var fableGlobal = function () {\n    var globalObj = typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : null;\n    if (typeof globalObj.__FABLE_CORE__ === \"undefined\") {\n        globalObj.__FABLE_CORE__ = {\n            types: new Map(),\n            symbols: {\n                reflection: Symbol(\"reflection\"),\n                generics: Symbol(\"generics\")\n            }\n        };\n    }\n    return globalObj.__FABLE_CORE__;\n}();\nexport function setType(fullName, cons) {\n    fableGlobal.types.set(fullName, cons);\n}\nexport function getType(fullName) {\n    return fableGlobal.types.get(fullName);\n}\nexport default fableGlobal.symbols;","var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nimport FSymbol from \"./Symbol\";\nexport var NonDeclaredType = function () {\n    function NonDeclaredType(kind, name, generics) {\n        _classCallCheck(this, NonDeclaredType);\n\n        this.kind = kind;\n        this.name = name;\n        this.generics = generics || [];\n    }\n\n    _createClass(NonDeclaredType, [{\n        key: \"Equals\",\n        value: function Equals(other) {\n            return this.kind === other.kind && this.name === other.name && equals(this.generics, other.generics);\n        }\n    }]);\n\n    return NonDeclaredType;\n}();\n\nvar GenericNonDeclaredType = function (_NonDeclaredType) {\n    _inherits(GenericNonDeclaredType, _NonDeclaredType);\n\n    function GenericNonDeclaredType(kind, generics) {\n        _classCallCheck(this, GenericNonDeclaredType);\n\n        return _possibleConstructorReturn(this, (GenericNonDeclaredType.__proto__ || Object.getPrototypeOf(GenericNonDeclaredType)).call(this, kind, null, generics));\n    }\n\n    _createClass(GenericNonDeclaredType, [{\n        key: FSymbol.generics,\n        value: function value() {\n            return this.generics;\n        }\n    }]);\n\n    return GenericNonDeclaredType;\n}(NonDeclaredType);\n\nexport var Any = new NonDeclaredType(\"Any\");\nexport var Unit = new NonDeclaredType(\"Unit\");\nexport function Option(t) {\n    return new GenericNonDeclaredType(\"Option\", [t]);\n}\nfunction FArray(t) {\n    return new GenericNonDeclaredType(\"Array\", [t]);\n}\nexport { FArray as Array };\nexport function Tuple(ts) {\n    return new GenericNonDeclaredType(\"Tuple\", ts);\n}\nexport function GenericParam(name) {\n    return new NonDeclaredType(\"GenericParam\", name);\n}\nexport function Interface(name) {\n    return new NonDeclaredType(\"Interface\", name);\n}\nexport function makeGeneric(typeDef, genArgs) {\n    return function (_typeDef) {\n        _inherits(_class, _typeDef);\n\n        function _class() {\n            _classCallCheck(this, _class);\n\n            return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));\n        }\n\n        _createClass(_class, [{\n            key: FSymbol.generics,\n            value: function value() {\n                return genArgs;\n            }\n        }]);\n\n        return _class;\n    }(typeDef);\n}\n/**\n * Checks if this a function constructor extending another with generic info.\n */\nexport function isGeneric(typ) {\n    return typeof typ === \"function\" && !!typ.prototype[FSymbol.generics];\n}\n/**\n * Returns the parent if this is a declared generic type or the argument otherwise.\n * Attention: Unlike .NET this doesn't throw an exception if type is not generic.\n*/\nexport function getDefinition(typ) {\n    return typeof typ === \"function\" && typ.prototype[FSymbol.generics] ? Object.getPrototypeOf(typ.prototype).constructor : typ;\n}\nexport function extendInfo(cons, info) {\n    var parent = Object.getPrototypeOf(cons.prototype);\n    if (typeof parent[FSymbol.reflection] === \"function\") {\n        var _ret = function () {\n            var newInfo = {},\n                parentInfo = parent[FSymbol.reflection]();\n            Object.getOwnPropertyNames(info).forEach(function (k) {\n                var i = info[k];\n                if ((typeof i === \"undefined\" ? \"undefined\" : _typeof(i)) === \"object\") {\n                    newInfo[k] = Array.isArray(i) ? (parentInfo[k] || []).concat(i) : Object.assign(parentInfo[k] || {}, i);\n                } else {\n                    newInfo[k] = i;\n                }\n            });\n            return {\n                v: newInfo\n            };\n        }();\n\n        if ((typeof _ret === \"undefined\" ? \"undefined\" : _typeof(_ret)) === \"object\") return _ret.v;\n    }\n    return info;\n}\nexport function hasInterface(obj, interfaceName) {\n    if (typeof obj[FSymbol.reflection] === \"function\") {\n        var interfaces = obj[FSymbol.reflection]().interfaces;\n        return Array.isArray(interfaces) && interfaces.indexOf(interfaceName) > -1;\n    }\n    return false;\n}\nexport function isArray(obj) {\n    return Array.isArray(obj) || ArrayBuffer.isView(obj);\n}\nexport function getRestParams(args, idx) {\n    for (var _len = args.length, restArgs = Array(_len > idx ? _len - idx : 0), _key = idx; _key < _len; _key++) {\n        restArgs[_key - idx] = args[_key];\n    }return restArgs;\n}\nexport function toString(o) {\n    return o != null && typeof o.ToString == \"function\" ? o.ToString() : String(o);\n}\nexport function hash(x) {\n    var s = JSON.stringify(x);\n    var h = 5381,\n        i = 0,\n        len = s.length;\n    while (i < len) {\n        h = h * 33 ^ s.charCodeAt(i++);\n    }\n    return h;\n}\nexport function equals(x, y) {\n    // Optimization if they are referencially equal\n    if (x === y) return true;else if (x == null) return y == null;else if (y == null) return false;else if (isGeneric(x) && isGeneric(y)) return getDefinition(x) === getDefinition(y) && equalsRecords(x.prototype[FSymbol.generics](), y.prototype[FSymbol.generics]());else if (Object.getPrototypeOf(x) !== Object.getPrototypeOf(y)) return false;else if (typeof x.Equals === \"function\") return x.Equals(y);else if (Array.isArray(x)) {\n        if (x.length != y.length) return false;\n        for (var i = 0; i < x.length; i++) {\n            if (!equals(x[i], y[i])) return false;\n        }return true;\n    } else if (ArrayBuffer.isView(x)) {\n        if (x.byteLength !== y.byteLength) return false;\n        var dv1 = new DataView(x.buffer),\n            dv2 = new DataView(y.buffer);\n        for (var _i = 0; _i < x.byteLength; _i++) {\n            if (dv1.getUint8(_i) !== dv2.getUint8(_i)) return false;\n        }return true;\n    } else if (x instanceof Date) return x.getTime() == y.getTime();else return false;\n}\nexport function compare(x, y) {\n    // Optimization if they are referencially equal\n    if (x === y) return 0;\n    if (x == null) return y == null ? 0 : -1;else if (y == null) return -1;else if (Object.getPrototypeOf(x) !== Object.getPrototypeOf(y)) return -1;else if (hasInterface(x, \"System.IComparable\")) return x.CompareTo(y);else if (Array.isArray(x)) {\n        if (x.length != y.length) return x.length < y.length ? -1 : 1;\n        for (var i = 0, j = 0; i < x.length; i++) {\n            if ((j = compare(x[i], y[i])) !== 0) return j;\n        }return 0;\n    } else if (ArrayBuffer.isView(x)) {\n        if (x.byteLength != y.byteLength) return x.byteLength < y.byteLength ? -1 : 1;\n        var dv1 = new DataView(x.buffer),\n            dv2 = new DataView(y.buffer);\n        for (var _i2 = 0, b1 = 0, b2 = 0; _i2 < x.byteLength; _i2++) {\n            b1 = dv1.getUint8(_i2), b2 = dv2.getUint8(_i2);\n            if (b1 < b2) return -1;\n            if (b1 > b2) return 1;\n        }\n        return 0;\n    } else if (x instanceof Date) return compare(x.getTime(), y.getTime());else return x < y ? -1 : 1;\n}\nexport function equalsRecords(x, y) {\n    // Optimization if they are referencially equal\n    if (x === y) {\n        return true;\n    } else {\n        var keys = Object.getOwnPropertyNames(x);\n        for (var i = 0; i < keys.length; i++) {\n            if (!equals(x[keys[i]], y[keys[i]])) return false;\n        }\n        return true;\n    }\n}\nexport function compareRecords(x, y) {\n    // Optimization if they are referencially equal\n    if (x === y) {\n        return 0;\n    } else {\n        var keys = Object.getOwnPropertyNames(x);\n        for (var i = 0; i < keys.length; i++) {\n            var res = compare(x[keys[i]], y[keys[i]]);\n            if (res !== 0) return res;\n        }\n        return 0;\n    }\n}\nexport function equalsUnions(x, y) {\n    // Optimization if they are referencially equal\n    if (x === y) {\n        return true;\n    } else if (x.Case !== y.Case) {\n        return false;\n    } else {\n        for (var i = 0; i < x.Fields.length; i++) {\n            if (!equals(x.Fields[i], y.Fields[i])) return false;\n        }\n        return true;\n    }\n}\nexport function compareUnions(x, y) {\n    // Optimization if they are referencially equal\n    if (x === y) {\n        return 0;\n    } else {\n        var res = compare(x.Case, y.Case);\n        if (res !== 0) return res;\n        for (var i = 0; i < x.Fields.length; i++) {\n            res = compare(x.Fields[i], y.Fields[i]);\n            if (res !== 0) return res;\n        }\n        return 0;\n    }\n}\nexport function createDisposable(f) {\n    return _defineProperty({\n        Dispose: f\n    }, FSymbol.reflection, function () {\n        return { interfaces: [\"System.IDisposable\"] };\n    });\n}\nexport function createObj(fields) {\n    var o = {};\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n        for (var _iterator = fields[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var kv = _step.value;\n\n            o[kv[0]] = kv[1];\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n            }\n        } finally {\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n\n    return o;\n}\nexport function toPlainJsObj(source) {\n    if (source != null && source.constructor != Object) {\n        var target = {};\n        var props = Object.getOwnPropertyNames(source);\n        for (var i = 0; i < props.length; i++) {\n            target[props[i]] = source[props[i]];\n        }\n        // Copy also properties from prototype, see #192\n        var proto = Object.getPrototypeOf(source);\n        if (proto != null) {\n            props = Object.getOwnPropertyNames(proto);\n            for (var _i3 = 0; _i3 < props.length; _i3++) {\n                var prop = Object.getOwnPropertyDescriptor(proto, props[_i3]);\n                if (prop.value) {\n                    target[props[_i3]] = prop.value;\n                } else if (prop.get) {\n                    target[props[_i3]] = prop.get.apply(source);\n                }\n            }\n        }\n        return target;\n    } else {\n        return source;\n    }\n}\nexport function round(value) {\n    var digits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    var m = Math.pow(10, digits);\n    var n = +(digits ? value * m : value).toFixed(8);\n    var i = Math.floor(n),\n        f = n - i;\n    var e = 1e-8;\n    var r = f > 0.5 - e && f < 0.5 + e ? i % 2 == 0 ? i : i + 1 : Math.round(n);\n    return digits ? r / m : r;\n}","var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nimport FSymbol from \"./Symbol\";\nimport { toString } from \"./Util\";\nimport { equals } from \"./Util\";\nimport { compare } from \"./Util\";\n// This module is split from List.ts to prevent cyclic dependencies\nexport function ofArray(args, base) {\n    var acc = base || new List();\n    for (var i = args.length - 1; i >= 0; i--) {\n        acc = new List(args[i], acc);\n    }\n    return acc;\n}\n\nvar List = function () {\n    function List(head, tail) {\n        _classCallCheck(this, List);\n\n        this.head = head;\n        this.tail = tail;\n    }\n\n    _createClass(List, [{\n        key: \"ToString\",\n        value: function ToString() {\n            return \"[\" + Array.from(this).map(toString).join(\"; \") + \"]\";\n        }\n    }, {\n        key: \"Equals\",\n        value: function Equals(x) {\n            // Optimization if they are referencially equal\n            if (this === x) {\n                return true;\n            } else {\n                var iter1 = this[Symbol.iterator](),\n                    iter2 = x[Symbol.iterator]();\n                for (;;) {\n                    var cur1 = iter1.next(),\n                        cur2 = iter2.next();\n                    if (cur1.done) return cur2.done ? true : false;else if (cur2.done) return false;else if (!equals(cur1.value, cur2.value)) return false;\n                }\n            }\n        }\n    }, {\n        key: \"CompareTo\",\n        value: function CompareTo(x) {\n            // Optimization if they are referencially equal\n            if (this === x) {\n                return 0;\n            } else {\n                var acc = 0;\n                var iter1 = this[Symbol.iterator](),\n                    iter2 = x[Symbol.iterator]();\n                for (;;) {\n                    var cur1 = iter1.next(),\n                        cur2 = iter2.next();\n                    if (cur1.done) return cur2.done ? acc : -1;else if (cur2.done) return 1;else {\n                        acc = compare(cur1.value, cur2.value);\n                        if (acc != 0) return acc;\n                    }\n                }\n            }\n        }\n    }, {\n        key: Symbol.iterator,\n        value: function value() {\n            var cur = this;\n            return {\n                next: function next() {\n                    var tmp = cur;\n                    cur = cur.tail;\n                    return { done: tmp.tail == null, value: tmp.head };\n                }\n            };\n        }\n        //   append(ys: List<T>): List<T> {\n        //     return append(this, ys);\n        //   }\n        //   choose<U>(f: (x: T) => U, xs: List<T>): List<U> {\n        //     return choose(f, this);\n        //   }\n        //   collect<U>(f: (x: T) => List<U>): List<U> {\n        //     return collect(f, this);\n        //   }\n        //   filter(f: (x: T) => boolean): List<T> {\n        //     return filter(f, this);\n        //   }\n        //   where(f: (x: T) => boolean): List<T> {\n        //     return filter(f, this);\n        //   }\n        //   map<U>(f: (x: T) => U): List<U> {\n        //     return map(f, this);\n        //   }\n        //   mapIndexed<U>(f: (i: number, x: T) => U): List<U> {\n        //     return mapIndexed(f, this);\n        //   }\n        //   partition(f: (x: T) => boolean): [List<T>, List<T>] {\n        //     return partition(f, this) as [List<T>, List<T>];\n        //   }\n        //   reverse(): List<T> {\n        //     return reverse(this);\n        //   }\n        //   slice(lower: number, upper: number): List<T> {\n        //     return slice(lower, upper, this);\n        //   }\n\n    }, {\n        key: FSymbol.reflection,\n        value: function value() {\n            return {\n                type: \"Microsoft.FSharp.Collections.FSharpList\",\n                interfaces: [\"System.IEquatable\", \"System.IComparable\"]\n            };\n        }\n    }, {\n        key: \"length\",\n        get: function get() {\n            var cur = this,\n                acc = 0;\n            while (cur.tail != null) {\n                cur = cur.tail;\n                acc++;\n            }\n            return acc;\n        }\n    }]);\n\n    return List;\n}();\n\nexport default List;","var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { equals } from \"./Util\";\nimport { compare } from \"./Util\";\nimport { permute as arrayPermute } from \"./Array\";\nimport List from \"./ListClass\";\nfunction __failIfNone(res) {\n    if (res == null) throw new Error(\"Seq did not contain any matching element\");\n    return res;\n}\nexport function toList(xs) {\n    return foldBack(function (x, acc) {\n        return new List(x, acc);\n    }, xs, new List());\n}\nexport function ofList(xs) {\n    return delay(function () {\n        return unfold(function (x) {\n            return x.tail != null ? [x.head, x.tail] : null;\n        }, xs);\n    });\n}\nexport function ofArray(xs) {\n    return delay(function () {\n        return unfold(function (i) {\n            return i < xs.length ? [xs[i], i + 1] : null;\n        }, 0);\n    });\n}\nexport function append(xs, ys) {\n    return delay(function () {\n        var firstDone = false;\n        var i = xs[Symbol.iterator]();\n        var iters = [i, null];\n        return unfold(function () {\n            var cur = void 0;\n            if (!firstDone) {\n                cur = iters[0].next();\n                if (!cur.done) {\n                    return [cur.value, iters];\n                } else {\n                    firstDone = true;\n                    iters = [null, ys[Symbol.iterator]()];\n                }\n            }\n            cur = iters[1].next();\n            return !cur.done ? [cur.value, iters] : null;\n        }, iters);\n    });\n}\nexport function average(xs) {\n    var count = 1;\n    var sum = reduce(function (acc, x) {\n        count++;\n        return acc + x;\n    }, xs);\n    return sum / count;\n}\nexport function averageBy(f, xs) {\n    var count = 1;\n    var sum = reduce(function (acc, x) {\n        count++;\n        return (count === 2 ? f(acc) : acc) + f(x);\n    }, xs);\n    return sum / count;\n}\nexport function concat(xs) {\n    return delay(function () {\n        var iter = xs[Symbol.iterator]();\n        var output = null;\n        return unfold(function (innerIter) {\n            var hasFinished = false;\n            while (!hasFinished) {\n                if (innerIter == null) {\n                    var cur = iter.next();\n                    if (!cur.done) {\n                        innerIter = cur.value[Symbol.iterator]();\n                    } else {\n                        hasFinished = true;\n                    }\n                } else {\n                    var _cur = innerIter.next();\n                    if (!_cur.done) {\n                        output = _cur.value;\n                        hasFinished = true;\n                    } else {\n                        innerIter = null;\n                    }\n                }\n            }\n            return innerIter != null && output != null ? [output, innerIter] : null;\n        }, null);\n    });\n}\nexport function collect(f, xs) {\n    return concat(map(f, xs));\n}\nexport function choose(f, xs) {\n    var trySkipToNext = function trySkipToNext(iter) {\n        var cur = iter.next();\n        if (!cur.done) {\n            var y = f(cur.value);\n            return y != null ? [y, iter] : trySkipToNext(iter);\n        }\n        return void 0;\n    };\n    return delay(function () {\n        return unfold(function (iter) {\n            return trySkipToNext(iter);\n        }, xs[Symbol.iterator]());\n    });\n}\nexport function compareWith(f, xs, ys) {\n    var nonZero = tryFind(function (i) {\n        return i != 0;\n    }, map2(function (x, y) {\n        return f(x, y);\n    }, xs, ys));\n    return nonZero != null ? nonZero : count(xs) - count(ys);\n}\nexport function delay(f) {\n    return _defineProperty({}, Symbol.iterator, function () {\n        return f()[Symbol.iterator]();\n    });\n}\nexport function empty() {\n    return unfold(function () {\n        return void 0;\n    });\n}\nexport function enumerateWhile(cond, xs) {\n    return concat(unfold(function () {\n        return cond() ? [xs, true] : null;\n    }));\n}\nexport function enumerateThenFinally(xs, finalFn) {\n    return delay(function () {\n        var iter = void 0;\n        try {\n            iter = xs[Symbol.iterator]();\n        } catch (err) {\n            return void 0;\n        } finally {\n            finalFn();\n        }\n        return unfold(function (iter) {\n            try {\n                var cur = iter.next();\n                return !cur.done ? [cur.value, iter] : null;\n            } catch (err) {\n                return void 0;\n            } finally {\n                finalFn();\n            }\n        }, iter);\n    });\n}\nexport function enumerateUsing(disp, work) {\n    var isDisposed = false;\n    var disposeOnce = function disposeOnce() {\n        if (!isDisposed) {\n            isDisposed = true;\n            disp.Dispose();\n        }\n    };\n    try {\n        return enumerateThenFinally(work(disp), disposeOnce);\n    } catch (err) {\n        return void 0;\n    } finally {\n        disposeOnce();\n    }\n}\nexport function exactlyOne(xs) {\n    var iter = xs[Symbol.iterator]();\n    var fst = iter.next();\n    if (fst.done) throw new Error(\"Seq was empty\");\n    var snd = iter.next();\n    if (!snd.done) throw new Error(\"Seq had multiple items\");\n    return fst.value;\n}\nexport function except(itemsToExclude, source) {\n    var exclusionItems = Array.from(itemsToExclude);\n    var testIsNotInExclusionItems = function testIsNotInExclusionItems(element) {\n        return !exclusionItems.some(function (excludedItem) {\n            return equals(excludedItem, element);\n        });\n    };\n    return filter(testIsNotInExclusionItems, source);\n}\nexport function exists(f, xs) {\n    function aux(iter) {\n        var cur = iter.next();\n        return !cur.done && (f(cur.value) || aux(iter));\n    }\n    return aux(xs[Symbol.iterator]());\n}\nexport function exists2(f, xs, ys) {\n    function aux(iter1, iter2) {\n        var cur1 = iter1.next(),\n            cur2 = iter2.next();\n        return !cur1.done && !cur2.done && (f(cur1.value, cur2.value) || aux(iter1, iter2));\n    }\n    return aux(xs[Symbol.iterator](), ys[Symbol.iterator]());\n}\nexport function filter(f, xs) {\n    function trySkipToNext(iter) {\n        var cur = iter.next();\n        while (!cur.done) {\n            if (f(cur.value)) {\n                return [cur.value, iter];\n            }\n            cur = iter.next();\n        }\n        return void 0;\n    }\n    return delay(function () {\n        return unfold(trySkipToNext, xs[Symbol.iterator]());\n    });\n}\nexport function where(f, xs) {\n    return filter(f, xs);\n}\nexport function fold(f, acc, xs) {\n    if (Array.isArray(xs) || ArrayBuffer.isView(xs)) {\n        return xs.reduce(f, acc);\n    } else {\n        var cur = void 0;\n        for (var i = 0, iter = xs[Symbol.iterator]();; i++) {\n            cur = iter.next();\n            if (cur.done) break;\n            acc = f(acc, cur.value, i);\n        }\n        return acc;\n    }\n}\nexport function foldBack(f, xs, acc) {\n    var arr = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs : Array.from(xs);\n    for (var i = arr.length - 1; i >= 0; i--) {\n        acc = f(arr[i], acc, i);\n    }\n    return acc;\n}\nexport function fold2(f, acc, xs, ys) {\n    var iter1 = xs[Symbol.iterator](),\n        iter2 = ys[Symbol.iterator]();\n    var cur1 = void 0,\n        cur2 = void 0;\n    for (var i = 0;; i++) {\n        cur1 = iter1.next();\n        cur2 = iter2.next();\n        if (cur1.done || cur2.done) {\n            break;\n        }\n        acc = f(acc, cur1.value, cur2.value, i);\n    }\n    return acc;\n}\nexport function foldBack2(f, xs, ys, acc) {\n    var ar1 = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs : Array.from(xs);\n    var ar2 = Array.isArray(ys) || ArrayBuffer.isView(ys) ? ys : Array.from(ys);\n    for (var i = ar1.length - 1; i >= 0; i--) {\n        acc = f(ar1[i], ar2[i], acc, i);\n    }\n    return acc;\n}\nexport function forAll(f, xs) {\n    return fold(function (acc, x) {\n        return acc && f(x);\n    }, true, xs);\n}\nexport function forAll2(f, xs, ys) {\n    return fold2(function (acc, x, y) {\n        return acc && f(x, y);\n    }, true, xs, ys);\n}\nexport function tryHead(xs) {\n    var iter = xs[Symbol.iterator]();\n    var cur = iter.next();\n    return cur.done ? null : cur.value;\n}\nexport function head(xs) {\n    return __failIfNone(tryHead(xs));\n}\nexport function initialize(n, f) {\n    return delay(function () {\n        return unfold(function (i) {\n            return i < n ? [f(i), i + 1] : null;\n        }, 0);\n    });\n}\nexport function initializeInfinite(f) {\n    return delay(function () {\n        return unfold(function (i) {\n            return [f(i), i + 1];\n        }, 0);\n    });\n}\nexport function tryItem(i, xs) {\n    if (i < 0) return null;\n    if (Array.isArray(xs) || ArrayBuffer.isView(xs)) return i < xs.length ? xs[i] : null;\n    for (var j = 0, iter = xs[Symbol.iterator]();; j++) {\n        var cur = iter.next();\n        if (cur.done) return null;\n        if (j === i) return cur.value;\n    }\n}\nexport function item(i, xs) {\n    return __failIfNone(tryItem(i, xs));\n}\nexport function iterate(f, xs) {\n    fold(function (_, x) {\n        return f(x);\n    }, null, xs);\n}\nexport function iterate2(f, xs, ys) {\n    fold2(function (_, x, y) {\n        return f(x, y);\n    }, null, xs, ys);\n}\nexport function iterateIndexed(f, xs) {\n    fold(function (_, x, i) {\n        return f(i, x);\n    }, null, xs);\n}\nexport function iterateIndexed2(f, xs, ys) {\n    fold2(function (_, x, y, i) {\n        return f(i, x, y);\n    }, null, xs, ys);\n}\nexport function isEmpty(xs) {\n    var i = xs[Symbol.iterator]();\n    return i.next().done;\n}\nexport function tryLast(xs) {\n    try {\n        return reduce(function (_, x) {\n            return x;\n        }, xs);\n    } catch (err) {\n        return null;\n    }\n}\nexport function last(xs) {\n    return __failIfNone(tryLast(xs));\n}\n// A export function 'length' method causes problems in JavaScript -- https://github.com/Microsoft/TypeScript/issues/442\nexport function count(xs) {\n    return Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs.length : fold(function (acc, x) {\n        return acc + 1;\n    }, 0, xs);\n}\nexport function map(f, xs) {\n    return delay(function () {\n        return unfold(function (iter) {\n            var cur = iter.next();\n            return !cur.done ? [f(cur.value), iter] : null;\n        }, xs[Symbol.iterator]());\n    });\n}\nexport function mapIndexed(f, xs) {\n    return delay(function () {\n        var i = 0;\n        return unfold(function (iter) {\n            var cur = iter.next();\n            return !cur.done ? [f(i++, cur.value), iter] : null;\n        }, xs[Symbol.iterator]());\n    });\n}\nexport function map2(f, xs, ys) {\n    return delay(function () {\n        var iter1 = xs[Symbol.iterator]();\n        var iter2 = ys[Symbol.iterator]();\n        return unfold(function () {\n            var cur1 = iter1.next(),\n                cur2 = iter2.next();\n            return !cur1.done && !cur2.done ? [f(cur1.value, cur2.value), null] : null;\n        });\n    });\n}\nexport function mapIndexed2(f, xs, ys) {\n    return delay(function () {\n        var i = 0;\n        var iter1 = xs[Symbol.iterator]();\n        var iter2 = ys[Symbol.iterator]();\n        return unfold(function () {\n            var cur1 = iter1.next(),\n                cur2 = iter2.next();\n            return !cur1.done && !cur2.done ? [f(i++, cur1.value, cur2.value), null] : null;\n        });\n    });\n}\nexport function map3(f, xs, ys, zs) {\n    return delay(function () {\n        var iter1 = xs[Symbol.iterator]();\n        var iter2 = ys[Symbol.iterator]();\n        var iter3 = zs[Symbol.iterator]();\n        return unfold(function () {\n            var cur1 = iter1.next(),\n                cur2 = iter2.next(),\n                cur3 = iter3.next();\n            return !cur1.done && !cur2.done && !cur3.done ? [f(cur1.value, cur2.value, cur3.value), null] : null;\n        });\n    });\n}\nexport function mapFold(f, acc, xs) {\n    var result = [];\n    var r = void 0;\n    var cur = void 0;\n    for (var i = 0, iter = xs[Symbol.iterator]();; i++) {\n        cur = iter.next();\n        if (cur.done) break;\n\n        var _f = f(acc, cur.value);\n\n        var _f2 = _slicedToArray(_f, 2);\n\n        r = _f2[0];\n        acc = _f2[1];\n\n        result.push(r);\n    }\n    return [result, acc];\n}\nexport function mapFoldBack(f, xs, acc) {\n    var arr = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs : Array.from(xs);\n    var result = [];\n    var r = void 0;\n    for (var i = arr.length - 1; i >= 0; i--) {\n        var _f3 = f(arr[i], acc);\n\n        var _f4 = _slicedToArray(_f3, 2);\n\n        r = _f4[0];\n        acc = _f4[1];\n\n        result.push(r);\n    }\n    return [result, acc];\n}\nexport function max(xs) {\n    return reduce(function (acc, x) {\n        return compare(acc, x) === 1 ? acc : x;\n    }, xs);\n}\nexport function maxBy(f, xs) {\n    return reduce(function (acc, x) {\n        return compare(f(acc), f(x)) === 1 ? acc : x;\n    }, xs);\n}\nexport function min(xs) {\n    return reduce(function (acc, x) {\n        return compare(acc, x) === -1 ? acc : x;\n    }, xs);\n}\nexport function minBy(f, xs) {\n    return reduce(function (acc, x) {\n        return compare(f(acc), f(x)) === -1 ? acc : x;\n    }, xs);\n}\nexport function pairwise(xs) {\n    return skip(2, scan(function (last, next) {\n        return [last[1], next];\n    }, [0, 0], xs));\n}\nexport function permute(f, xs) {\n    return ofArray(arrayPermute(f, Array.from(xs)));\n}\nexport function rangeStep(first, step, last) {\n    if (step === 0) throw new Error(\"Step cannot be 0\");\n    return delay(function () {\n        return unfold(function (x) {\n            return step > 0 && x <= last || step < 0 && x >= last ? [x, x + step] : null;\n        }, first);\n    });\n}\nexport function rangeChar(first, last) {\n    return delay(function () {\n        return unfold(function (x) {\n            return x <= last ? [x, String.fromCharCode(x.charCodeAt(0) + 1)] : null;\n        }, first);\n    });\n}\nexport function range(first, last) {\n    return rangeStep(first, 1, last);\n}\nexport function readOnly(xs) {\n    return map(function (x) {\n        return x;\n    }, xs);\n}\nexport function reduce(f, xs) {\n    if (Array.isArray(xs) || ArrayBuffer.isView(xs)) return xs.reduce(f);\n    var iter = xs[Symbol.iterator]();\n    var cur = iter.next();\n    if (cur.done) throw new Error(\"Seq was empty\");\n    var acc = cur.value;\n    for (;;) {\n        cur = iter.next();\n        if (cur.done) break;\n        acc = f(acc, cur.value);\n    }\n    return acc;\n}\nexport function reduceBack(f, xs) {\n    var ar = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs : Array.from(xs);\n    if (ar.length === 0) throw new Error(\"Seq was empty\");\n    var acc = ar[ar.length - 1];\n    for (var i = ar.length - 2; i >= 0; i--) {\n        acc = f(ar[i], acc, i);\n    }return acc;\n}\nexport function replicate(n, x) {\n    return initialize(n, function () {\n        return x;\n    });\n}\nexport function reverse(xs) {\n    var ar = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs.slice(0) : Array.from(xs);\n    return ofArray(ar.reverse());\n}\nexport function scan(f, seed, xs) {\n    return delay(function () {\n        var iter = xs[Symbol.iterator]();\n        return unfold(function (acc) {\n            if (acc == null) return [seed, seed];\n            var cur = iter.next();\n            if (!cur.done) {\n                acc = f(acc, cur.value);\n                return [acc, acc];\n            }\n            return void 0;\n        }, null);\n    });\n}\nexport function scanBack(f, xs, seed) {\n    return reverse(scan(function (acc, x) {\n        return f(x, acc);\n    }, seed, reverse(xs)));\n}\nexport function singleton(x) {\n    return unfold(function (x) {\n        return x != null ? [x, null] : null;\n    }, x);\n}\nexport function skip(n, xs) {\n    return _defineProperty({}, Symbol.iterator, function () {\n        var iter = xs[Symbol.iterator]();\n        for (var i = 1; i <= n; i++) {\n            if (iter.next().done) throw new Error(\"Seq has not enough elements\");\n        }return iter;\n    });\n}\nexport function skipWhile(f, xs) {\n    return delay(function () {\n        var hasPassed = false;\n        return filter(function (x) {\n            return hasPassed || (hasPassed = !f(x));\n        }, xs);\n    });\n}\nexport function sortWith(f, xs) {\n    var ys = Array.from(xs);\n    return ofArray(ys.sort(f));\n}\nexport function sum(xs) {\n    return fold(function (acc, x) {\n        return acc + x;\n    }, 0, xs);\n}\nexport function sumBy(f, xs) {\n    return fold(function (acc, x) {\n        return acc + f(x);\n    }, 0, xs);\n}\nexport function tail(xs) {\n    var iter = xs[Symbol.iterator]();\n    var cur = iter.next();\n    if (cur.done) throw new Error(\"Seq was empty\");\n    return _defineProperty({}, Symbol.iterator, function () {\n        return iter;\n    });\n}\nexport function take(n, xs) {\n    var truncate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    return delay(function () {\n        var iter = xs[Symbol.iterator]();\n        return unfold(function (i) {\n            if (i < n) {\n                var cur = iter.next();\n                if (!cur.done) return [cur.value, i + 1];\n                if (!truncate) throw new Error(\"Seq has not enough elements\");\n            }\n            return void 0;\n        }, 0);\n    });\n}\nexport function truncate(n, xs) {\n    return take(n, xs, true);\n}\nexport function takeWhile(f, xs) {\n    return delay(function () {\n        var iter = xs[Symbol.iterator]();\n        return unfold(function (i) {\n            var cur = iter.next();\n            if (!cur.done && f(cur.value)) return [cur.value, null];\n            return void 0;\n        }, 0);\n    });\n}\nexport function tryFind(f, xs, defaultValue) {\n    for (var i = 0, iter = xs[Symbol.iterator]();; i++) {\n        var cur = iter.next();\n        if (cur.done) return defaultValue === void 0 ? null : defaultValue;\n        if (f(cur.value, i)) return cur.value;\n    }\n}\nexport function find(f, xs) {\n    return __failIfNone(tryFind(f, xs));\n}\nexport function tryFindBack(f, xs, defaultValue) {\n    var match = null;\n    for (var i = 0, iter = xs[Symbol.iterator]();; i++) {\n        var cur = iter.next();\n        if (cur.done) return match === null ? defaultValue === void 0 ? null : defaultValue : match;\n        if (f(cur.value, i)) match = cur.value;\n    }\n}\nexport function findBack(f, xs) {\n    return __failIfNone(tryFindBack(f, xs));\n}\nexport function tryFindIndex(f, xs) {\n    for (var i = 0, iter = xs[Symbol.iterator]();; i++) {\n        var cur = iter.next();\n        if (cur.done) return null;\n        if (f(cur.value, i)) return i;\n    }\n}\nexport function findIndex(f, xs) {\n    return __failIfNone(tryFindIndex(f, xs));\n}\nexport function tryFindIndexBack(f, xs) {\n    var match = -1;\n    for (var i = 0, iter = xs[Symbol.iterator]();; i++) {\n        var cur = iter.next();\n        if (cur.done) return match === -1 ? null : match;\n        if (f(cur.value, i)) match = i;\n    }\n}\nexport function findIndexBack(f, xs) {\n    return __failIfNone(tryFindIndexBack(f, xs));\n}\nexport function tryPick(f, xs) {\n    for (var i = 0, iter = xs[Symbol.iterator]();; i++) {\n        var cur = iter.next();\n        if (cur.done) break;\n        var y = f(cur.value, i);\n        if (y != null) return y;\n    }\n    return void 0;\n}\nexport function pick(f, xs) {\n    return __failIfNone(tryPick(f, xs));\n}\nexport function unfold(f, acc) {\n    return _defineProperty({}, Symbol.iterator, function () {\n        return {\n            next: function next() {\n                var res = f(acc);\n                if (res != null) {\n                    acc = res[1];\n                    return { done: false, value: res[0] };\n                }\n                return { done: true };\n            }\n        };\n    });\n}\nexport function zip(xs, ys) {\n    return map2(function (x, y) {\n        return [x, y];\n    }, xs, ys);\n}\nexport function zip3(xs, ys, zs) {\n    return map3(function (x, y, z) {\n        return [x, y, z];\n    }, xs, ys, zs);\n}","export function create(pattern, options) {\n    var flags = \"g\";\n    flags += options & 1 ? \"i\" : \"\";\n    flags += options & 2 ? \"m\" : \"\";\n    return new RegExp(pattern, flags);\n}\n// From http://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex\nexport function escape(str) {\n    return str.replace(/[\\-\\[\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\n}\nexport function unescape(str) {\n    return str.replace(/\\\\([\\-\\[\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|])/g, \"$1\");\n}\nexport function isMatch(str, pattern) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    var reg = str instanceof RegExp ? (reg = str, str = pattern, reg.lastIndex = options, reg) : reg = create(pattern, options);\n    return reg.test(str);\n}\nexport function match(str, pattern) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    var reg = str instanceof RegExp ? (reg = str, str = pattern, reg.lastIndex = options, reg) : reg = create(pattern, options);\n    return reg.exec(str);\n}\nexport function matches(str, pattern) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    var reg = str instanceof RegExp ? (reg = str, str = pattern, reg.lastIndex = options, reg) : reg = create(pattern, options);\n    if (!reg.global) throw new Error(\"Non-global RegExp\"); // Prevent infinite loop\n    var m = void 0;\n    var matches = [];\n    while ((m = reg.exec(str)) !== null) {\n        matches.push(m);\n    }return matches;\n}\nexport function options(reg) {\n    var options = 256; // ECMAScript\n    options |= reg.ignoreCase ? 1 : 0;\n    options |= reg.multiline ? 2 : 0;\n    return options;\n}\nexport function replace(reg, input, replacement, limit) {\n    var offset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n\n    function replacer() {\n        var res = arguments[0];\n        if (limit !== 0) {\n            limit--;\n            var _match = [];\n            var len = arguments.length;\n            for (var i = 0; i < len - 2; i++) {\n                _match.push(arguments[i]);\n            }_match.index = arguments[len - 2];\n            _match.input = arguments[len - 1];\n            res = replacement(_match);\n        }\n        return res;\n    }\n    if (typeof reg == \"string\") {\n        var tmp = reg;\n        reg = create(input, limit);\n        input = tmp;\n        limit = undefined;\n    }\n    if (typeof replacement == \"function\") {\n        limit = limit == null ? -1 : limit;\n        return input.substring(0, offset) + input.substring(offset).replace(reg, replacer);\n    } else {\n        if (limit != null) {\n            var m = void 0;\n            var sub1 = input.substring(offset);\n            var _matches = matches(reg, sub1);\n            var sub2 = matches.length > limit ? (m = _matches[limit - 1], sub1.substring(0, m.index + m[0].length)) : sub1;\n            return input.substring(0, offset) + sub2.replace(reg, replacement) + input.substring(offset + sub2.length);\n        } else {\n            return input.replace(reg, replacement);\n        }\n    }\n}\nexport function split(reg, input, limit) {\n    var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n    if (typeof reg == \"string\") {\n        var tmp = reg;\n        reg = create(input, limit);\n        input = tmp;\n        limit = undefined;\n    }\n    input = input.substring(offset);\n    return input.split(reg, limit);\n}","import { compare as utilCompare } from \"./Util\";\nexport function create() {\n    var d = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var h = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var m = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var ms = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n\n    switch (arguments.length) {\n        case 1:\n            // ticks\n            return fromTicks(arguments[0]);\n        case 3:\n            // h,m,s\n            d = 0, h = arguments[0], m = arguments[1], s = arguments[2], ms = 0;\n            break;\n        default:\n            // d,h,m,s,ms\n            d = arguments[0], h = arguments[1], m = arguments[2], s = arguments[3], ms = arguments[4] || 0;\n            break;\n    }\n    return d * 86400000 + h * 3600000 + m * 60000 + s * 1000 + ms;\n}\nexport function fromTicks(ticks) {\n    return ticks / 10000;\n}\nexport function fromDays(d) {\n    return create(d, 0, 0, 0);\n}\nexport function fromHours(h) {\n    return create(h, 0, 0);\n}\nexport function fromMinutes(m) {\n    return create(0, m, 0);\n}\nexport function fromSeconds(s) {\n    return create(0, 0, s);\n}\nexport function days(ts) {\n    return Math.floor(ts / 86400000);\n}\nexport function hours(ts) {\n    return Math.floor(ts % 86400000 / 3600000);\n}\nexport function minutes(ts) {\n    return Math.floor(ts % 3600000 / 60000);\n}\nexport function seconds(ts) {\n    return Math.floor(ts % 60000 / 1000);\n}\nexport function milliseconds(ts) {\n    return Math.floor(ts % 1000);\n}\nexport function ticks(ts) {\n    return ts * 10000;\n}\nexport function totalDays(ts) {\n    return ts / 86400000;\n}\nexport function totalHours(ts) {\n    return ts / 3600000;\n}\nexport function totalMinutes(ts) {\n    return ts / 60000;\n}\nexport function totalSeconds(ts) {\n    return ts / 1000;\n}\nexport function negate(ts) {\n    return ts * -1;\n}\nexport function add(ts1, ts2) {\n    return ts1 + ts2;\n}\nexport function subtract(ts1, ts2) {\n    return ts1 - ts2;\n}\nexport function compare(x, y) {\n    return utilCompare(x, y);\n}\nexport function compareTo(x, y) {\n    return utilCompare(x, y);\n}\nexport function duration(x) {\n    return Math.abs(x);\n}","import { create as timeSpanCreate } from \"./TimeSpan\";\nimport { compare as utilCompare } from \"./Util\";\nfunction __changeKind(d, kind) {\n    var d2 = void 0;\n    return d.kind == kind ? d : (d2 = new Date(d.getTime()), d2.kind = kind, d2);\n}\nfunction __getValue(d, key) {\n    return d[(d.kind == 1 /* UTC */ ? \"getUTC\" : \"get\") + key]();\n}\nexport function minValue() {\n    return parse(-8640000000000000, 1);\n}\nexport function maxValue() {\n    return parse(8640000000000000, 1);\n}\nexport function parse(v, kind) {\n    var date = v == null ? new Date() : new Date(v);\n    if (isNaN(date.getTime())) throw new Error(\"The string is not a valid Date.\");\n    date.kind = kind || (typeof v == \"string\" && v.slice(-1) == \"Z\" ? 1 /* UTC */ : 2 /* Local */);\n    return date;\n}\nexport function tryParse(v) {\n    try {\n        return [true, parse(v)];\n    } catch (_err) {\n        return [false, minValue()];\n    }\n}\nexport function create(year, month, day) /* Local */{\n    var h = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var m = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    var s = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    var ms = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n    var kind = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 2;\n\n    var date = kind === 1 /* UTC */ ? new Date(Date.UTC(year, month - 1, day, h, m, s, ms)) : new Date(year, month - 1, day, h, m, s, ms);\n    if (isNaN(date.getTime())) throw new Error(\"The parameters describe an unrepresentable Date.\");\n    date.kind = kind;\n    return date;\n}\nexport function now() {\n    return parse();\n}\nexport function utcNow() {\n    return parse(null, 1);\n}\nexport function today() {\n    return date(now());\n}\nexport function isLeapYear(year) {\n    return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;\n}\nexport function daysInMonth(year, month) {\n    return month == 2 ? isLeapYear(year) ? 29 : 28 : month >= 8 ? month % 2 == 0 ? 31 : 30 : month % 2 == 0 ? 30 : 31;\n}\nexport function toUniversalTime(d) {\n    return __changeKind(d, 1);\n}\nexport function toLocalTime(d) {\n    return __changeKind(d, 2);\n}\nexport function timeOfDay(d) {\n    return timeSpanCreate(0, hour(d), minute(d), second(d), millisecond(d));\n}\nexport function date(d) {\n    return create(year(d), month(d), day(d), 0, 0, 0, 0, d.kind);\n}\nexport function day(d) {\n    return __getValue(d, \"Date\");\n}\nexport function hour(d) {\n    return __getValue(d, \"Hours\");\n}\nexport function millisecond(d) {\n    return __getValue(d, \"Milliseconds\");\n}\nexport function minute(d) {\n    return __getValue(d, \"Minutes\");\n}\nexport function month(d) {\n    return __getValue(d, \"Month\") + 1;\n}\nexport function second(d) {\n    return __getValue(d, \"Seconds\");\n}\nexport function year(d) {\n    return __getValue(d, \"FullYear\");\n}\nexport function ticks(d) {\n    return (d.getTime() + 6.2135604e+13 /* millisecondsJSOffset */) * 10000;\n}\nexport function toBinary(d) {\n    return ticks(d);\n}\nexport function dayOfWeek(d) {\n    return __getValue(d, \"Day\");\n}\nexport function dayOfYear(d) {\n    var _year = year(d);\n    var _month = month(d);\n    var _day = day(d);\n    for (var i = 1; i < _month; i++) {\n        _day += daysInMonth(_year, i);\n    }return _day;\n}\nexport function add(d, ts) {\n    return parse(d.getTime() + ts, d.kind);\n}\nexport function addDays(d, v) {\n    return parse(d.getTime() + v * 86400000, d.kind);\n}\nexport function addHours(d, v) {\n    return parse(d.getTime() + v * 3600000, d.kind);\n}\nexport function addMinutes(d, v) {\n    return parse(d.getTime() + v * 60000, d.kind);\n}\nexport function addSeconds(d, v) {\n    return parse(d.getTime() + v * 1000, d.kind);\n}\nexport function addMilliseconds(d, v) {\n    return parse(d.getTime() + v, d.kind);\n}\nexport function addTicks(d, v) {\n    return parse(d.getTime() + v / 10000, d.kind);\n}\nexport function addYears(d, v) {\n    var newMonth = month(d);\n    var newYear = year(d) + v;\n    var _daysInMonth = daysInMonth(newYear, newMonth);\n    var newDay = Math.min(_daysInMonth, day(d));\n    return create(newYear, newMonth, newDay, hour(d), minute(d), second(d), millisecond(d), d.kind);\n}\nexport function addMonths(d, v) {\n    var newMonth = month(d) + v;\n    var newMonth_ = 0;\n    var yearOffset = 0;\n    if (newMonth > 12) {\n        newMonth_ = newMonth % 12;\n        yearOffset = Math.floor(newMonth / 12);\n        newMonth = newMonth_;\n    } else if (newMonth < 1) {\n        newMonth_ = 12 + newMonth % 12;\n        yearOffset = Math.floor(newMonth / 12) + (newMonth_ == 12 ? -1 : 0);\n        newMonth = newMonth_;\n    }\n    var newYear = year(d) + yearOffset;\n    var _daysInMonth = daysInMonth(newYear, newMonth);\n    var newDay = Math.min(_daysInMonth, day(d));\n    return create(newYear, newMonth, newDay, hour(d), minute(d), second(d), millisecond(d), d.kind);\n}\nexport function subtract(d, that) {\n    return typeof that == \"number\" ? parse(d.getTime() - that, d.kind) : d.getTime() - that.getTime();\n}\nexport function toLongDateString(d) {\n    return d.toDateString();\n}\nexport function toShortDateString(d) {\n    return d.toLocaleDateString();\n}\nexport function toLongTimeString(d) {\n    return d.toLocaleTimeString();\n}\nexport function toShortTimeString(d) {\n    return d.toLocaleTimeString().replace(/:\\d\\d(?!:)/, \"\");\n}\nexport function equals(d1, d2) {\n    return d1.getTime() == d2.getTime();\n}\nexport function compare(x, y) {\n    return utilCompare(x, y);\n}\nexport function compareTo(x, y) {\n    return utilCompare(x, y);\n}\nexport function op_Addition(x, y) {\n    return add(x, y);\n}\nexport function op_Subtraction(x, y) {\n    return subtract(x, y);\n}","var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nimport { toString } from \"./Util\";\nimport { getRestParams } from \"./Util\";\nimport { escape } from \"./RegExp\";\nimport { second } from \"./Date\";\nimport { minute } from \"./Date\";\nimport { hour } from \"./Date\";\nimport { day } from \"./Date\";\nimport { month } from \"./Date\";\nimport { year } from \"./Date\";\nvar fsFormatRegExp = /(^|[^%])%([0+ ]*)(-?\\d+)?(?:\\.(\\d+))?(\\w)/;\nvar formatRegExp = /\\{(\\d+)(,-?\\d+)?(?:\\:(.+?))?\\}/g;\nfunction toHex(value) {\n    return value < 0 ? \"ff\" + (16777215 - (Math.abs(value) - 1)).toString(16) : value.toString(16);\n}\nexport function fsFormat(str) {\n    var _cont = void 0;\n    function isObject(x) {\n        return x !== null && (typeof x === \"undefined\" ? \"undefined\" : _typeof(x)) === \"object\" && !(x instanceof Number) && !(x instanceof String) && !(x instanceof Boolean);\n    }\n    function formatOnce(str, rep) {\n        return str.replace(fsFormatRegExp, function (_, prefix, flags, pad, precision, format) {\n            switch (format) {\n                case \"f\":\n                case \"F\":\n                    rep = rep.toFixed(precision || 6);\n                    break;\n                case \"g\":\n                case \"G\":\n                    rep = rep.toPrecision(precision);\n                    break;\n                case \"e\":\n                case \"E\":\n                    rep = rep.toExponential(precision);\n                    break;\n                case \"O\":\n                    rep = toString(rep);\n                    break;\n                case \"A\":\n                    try {\n                        rep = JSON.stringify(rep, function (k, v) {\n                            return v && v[Symbol.iterator] && !Array.isArray(v) && isObject(v) ? Array.from(v) : v;\n                        });\n                    } catch (err) {\n                        // Fallback for objects with circular references\n                        rep = \"{\" + Object.getOwnPropertyNames(rep).map(function (k) {\n                            return k + \": \" + String(rep[k]);\n                        }).join(\", \") + \"}\";\n                    }\n                    break;\n                case \"x\":\n                    rep = toHex(Number(rep));\n                    break;\n                case \"X\":\n                    rep = toHex(Number(rep)).toUpperCase();\n                    break;\n            }\n            var plusPrefix = flags.indexOf(\"+\") >= 0 && parseInt(rep) >= 0;\n            if (!isNaN(pad = parseInt(pad))) {\n                var ch = pad >= 0 && flags.indexOf(\"0\") >= 0 ? \"0\" : \" \";\n                rep = padLeft(rep, Math.abs(pad) - (plusPrefix ? 1 : 0), ch, pad < 0);\n            }\n            var once = prefix + (plusPrefix ? \"+\" + rep : rep);\n            return once.replace(/%/g, \"%%\");\n        });\n    }\n    function makeFn(str) {\n        return function (rep) {\n            var str2 = formatOnce(str, rep);\n            return fsFormatRegExp.test(str2) ? makeFn(str2) : _cont(str2.replace(/%%/g, \"%\"));\n        };\n    }\n\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n    }\n\n    if (args.length === 0) {\n        return function (cont) {\n            _cont = cont;\n            return fsFormatRegExp.test(str) ? makeFn(str) : _cont(str);\n        };\n    } else {\n        for (var i = 0; i < args.length; i++) {\n            str = formatOnce(str, args[i]);\n        }\n        return str.replace(/%%/g, \"%\");\n    }\n}\nexport function format(str) {\n    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n    }\n\n    return str.replace(formatRegExp, function (match, idx, pad, format) {\n        var rep = args[idx],\n            padSymbol = \" \";\n        if (typeof rep === \"number\") {\n            switch ((format || \"\").substring(0, 1)) {\n                case \"f\":\n                case \"F\":\n                    rep = format.length > 1 ? rep.toFixed(format.substring(1)) : rep.toFixed(2);\n                    break;\n                case \"g\":\n                case \"G\":\n                    rep = format.length > 1 ? rep.toPrecision(format.substring(1)) : rep.toPrecision();\n                    break;\n                case \"e\":\n                case \"E\":\n                    rep = format.length > 1 ? rep.toExponential(format.substring(1)) : rep.toExponential();\n                    break;\n                case \"p\":\n                case \"P\":\n                    rep = (format.length > 1 ? (rep * 100).toFixed(format.substring(1)) : (rep * 100).toFixed(2)) + \" %\";\n                    break;\n                case \"x\":\n                    rep = toHex(Number(rep));\n                    break;\n                case \"X\":\n                    rep = toHex(Number(rep)).toUpperCase();\n                    break;\n                default:\n                    var m = /^(0+)(\\.0+)?$/.exec(format);\n                    if (m != null) {\n                        var decs = 0;\n                        if (m[2] != null) rep = rep.toFixed(decs = m[2].length - 1);\n                        pad = \",\" + (m[1].length + (decs ? decs + 1 : 0)).toString();\n                        padSymbol = \"0\";\n                    } else if (format) {\n                        rep = format;\n                    }\n            }\n        } else if (rep instanceof Date) {\n            if (format.length === 1) {\n                switch (format) {\n                    case \"D\":\n                        rep = rep.toDateString();\n                        break;\n                    case \"T\":\n                        rep = rep.toLocaleTimeString();\n                        break;\n                    case \"d\":\n                        rep = rep.toLocaleDateString();\n                        break;\n                    case \"t\":\n                        rep = rep.toLocaleTimeString().replace(/:\\d\\d(?!:)/, \"\");\n                        break;\n                    case \"o\":\n                    case \"O\":\n                        if (rep.kind === 2 /* Local */) {\n                                var offset = rep.getTimezoneOffset() * -1;\n                                rep = format(\"{0:yyyy-MM-dd}T{0:HH:mm}:{1:00.000}{2}{3:00}:{4:00}\", rep, second(rep), offset >= 0 ? \"+\" : \"-\", ~~(offset / 60), offset % 60);\n                            } else {\n                            rep = rep.toISOString();\n                        }\n                }\n            } else {\n                rep = format.replace(/\\w+/g, function (match2) {\n                    var rep2 = match2;\n                    switch (match2.substring(0, 1)) {\n                        case \"y\":\n                            rep2 = match2.length < 4 ? year(rep) % 100 : year(rep);\n                            break;\n                        case \"h\":\n                            rep2 = rep.getHours() > 12 ? hour(rep) % 12 : hour(rep);\n                            break;\n                        case \"M\":\n                            rep2 = month(rep);\n                            break;\n                        case \"d\":\n                            rep2 = day(rep);\n                            break;\n                        case \"H\":\n                            rep2 = hour(rep);\n                            break;\n                        case \"m\":\n                            rep2 = minute(rep);\n                            break;\n                        case \"s\":\n                            rep2 = second(rep);\n                            break;\n                    }\n                    if (rep2 !== match2 && rep2 < 10 && match2.length > 1) {\n                        rep2 = \"0\" + rep2;\n                    }\n                    return rep2;\n                });\n            }\n        }\n        if (!isNaN(pad = parseInt((pad || \"\").substring(1)))) {\n            rep = padLeft(rep, Math.abs(pad), padSymbol, pad < 0);\n        }\n        return rep;\n    });\n}\nexport function endsWith(str, search) {\n    var idx = str.lastIndexOf(search);\n    return idx >= 0 && idx == str.length - search.length;\n}\nexport function initialize(n, f) {\n    if (n < 0) throw new Error(\"String length must be non-negative\");\n    var xs = new Array(n);\n    for (var i = 0; i < n; i++) {\n        xs[i] = f(i);\n    }return xs.join(\"\");\n}\nexport function insert(str, startIndex, value) {\n    if (startIndex < 0 || startIndex > str.length) {\n        throw new Error(\"startIndex is negative or greater than the length of this instance.\");\n    }\n    return str.substring(0, startIndex) + value + str.substring(startIndex);\n}\nexport function isNullOrEmpty(str) {\n    return typeof str !== \"string\" || str.length == 0;\n}\nexport function isNullOrWhiteSpace(str) {\n    return typeof str !== \"string\" || /^\\s*$/.test(str);\n}\nexport function join(delimiter, xs) {\n    xs = typeof xs == \"string\" ? getRestParams(arguments, 1) : xs;\n    return (Array.isArray(xs) ? xs : Array.from(xs)).join(delimiter);\n}\nexport function newGuid() {\n    var uuid = \"\";\n    for (var i = 0; i < 32; i++) {\n        var random = Math.random() * 16 | 0;\n        if (i === 8 || i === 12 || i === 16 || i === 20) uuid += \"-\";\n        uuid += (i === 12 ? 4 : i === 16 ? random & 3 | 8 : random).toString(16);\n    }\n    return uuid;\n}\nexport function padLeft(str, len, ch, isRight) {\n    ch = ch || \" \";\n    str = String(str);\n    len = len - str.length;\n    for (var i = -1; ++i < len;) {\n        str = isRight ? str + ch : ch + str;\n    }return str;\n}\nexport function padRight(str, len, ch) {\n    return padLeft(str, len, ch, true);\n}\nexport function remove(str, startIndex, count) {\n    if (startIndex >= str.length) {\n        throw new Error(\"startIndex must be less than length of string\");\n    }\n    if (typeof count === \"number\" && startIndex + count > str.length) {\n        throw new Error(\"Index and count must refer to a location within the string.\");\n    }\n    return str.slice(0, startIndex) + (typeof count === \"number\" ? str.substr(startIndex + count) : \"\");\n}\nexport function replace(str, search, replace) {\n    return str.replace(new RegExp(escape(search), \"g\"), replace);\n}\nexport function replicate(n, x) {\n    return initialize(n, function () {\n        return x;\n    });\n}\nexport function split(str, splitters, count, removeEmpty) {\n    count = typeof count == \"number\" ? count : null;\n    removeEmpty = typeof removeEmpty == \"number\" ? removeEmpty : null;\n    if (count < 0) throw new Error(\"Count cannot be less than zero\");\n    if (count === 0) return [];\n    splitters = Array.isArray(splitters) ? splitters : getRestParams(arguments, 1);\n    splitters = splitters.map(function (x) {\n        return escape(x);\n    });\n    splitters = splitters.length > 0 ? splitters : [\" \"];\n    var m = void 0;\n    var i = 0;\n    var splits = [];\n    var reg = new RegExp(splitters.join(\"|\"), \"g\");\n    while ((count == null || count > 1) && (m = reg.exec(str)) !== null) {\n        if (!removeEmpty || m.index - i > 0) {\n            count = count != null ? count - 1 : count;\n            splits.push(str.substring(i, m.index));\n        }\n        i = reg.lastIndex;\n    }\n    if (!removeEmpty || str.length - i > 0) splits.push(str.substring(i));\n    return splits;\n}\nexport function trim(str, side) {\n    for (var _len3 = arguments.length, chars = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n        chars[_key3 - 2] = arguments[_key3];\n    }\n\n    if (side == \"both\" && chars.length == 0) return str.trim();\n    if (side == \"start\" || side == \"both\") {\n        var reg = chars.length == 0 ? /^\\s+/ : new RegExp(\"^[\" + escape(chars.join(\"\")) + \"]+\");\n        str = str.replace(reg, \"\");\n    }\n    if (side == \"end\" || side == \"both\") {\n        var _reg = chars.length == 0 ? /\\s+$/ : new RegExp(\"[\" + escape(chars.join(\"\")) + \"]+$\");\n        str = str.replace(_reg, \"\");\n    }\n    return str;\n}","(**\n - title: Bar chart sample\n - tagline: Bar chart implemented using Fable-D3 bindings\n - app-style: width:800px; margin:20px auto 50px auto;\n - intro: Creating a bar chart using Fable-D3 bindings\n*)\n\n#r \"../../node_modules/fable-core/Fable.Core.dll\"\n#load \"../../node_modules/fable-import-d3/Fable.Import.D3.fs\"\n\nopen Fable.Core\nopen Fable.Core.JsInterop\nopen Fable.Import\nopen Fable.Import.Browser\n\nlet random = new System.Random()\nlet dataset = Array.init 25 (fun _ -> (random.Next(3,25)))\nlet barHeight x = x * 5 \nlet barPadding = 1.\nlet width = 500.\nlet height = 100.\nlet dataSetLength = float dataset.Length\n\nlet svg = D3.Globals.select(\"#display\")\n                    .append(\"svg\")\n                    .attr(\"width\", U3.Case1 width)\n                    .attr(\"height\", U3.Case1 height)\n\nsvg.selectAll(\"rect\")\n    .data(dataset)\n|> fun x -> (unbox<D3.Selection.Update<int>> x).enter()\n|> fun x -> x.append(\"rect\")\n|> fun x -> x.attr(\"width\", fun _ _ _ -> U3.Case1 (System.Math.Abs(width / dataSetLength - barPadding)))\n                .attr(\"height\", fun data _ _ -> U3.Case1 (float data * 4.))\n                .attr(\"x\", fun _ x _ -> U3.Case1 (x * (width/dataSetLength))) \n                .attr(\"y\", fun data _ _ -> U3.Case1 (height - float data * 4.))\n                .attr(\"fill\", fun data _ _ -> U3.Case2 (sprintf \"rgb(63,%A,150)\" (data * 10))) \n|> ignore\n            \n\nsvg.selectAll(\"text\")\n    .data(dataset)\n|> fun x -> (unbox<D3.Selection.Update<int>> x).enter()\n|> fun x -> x.append(\"text\")\n|> fun x -> x.text(fun data _ _ -> U3.Case2 (string data))\n             .attr(\"x\", fun _ x _ -> U3.Case1 (x * (width/dataSetLength))) \n             .attr(\"y\", fun data _ _ -> U3.Case1 (height - (float data * 4.)))\n|> ignore"],"names":["_createClass","_classCallCheck","create","_typeof","d3.select"],"mappings":"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"}